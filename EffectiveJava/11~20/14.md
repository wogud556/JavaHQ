### 아이템 14 Comparable 을 구현할지 고려하라
- compareTo 에 대해 이야기를 하면 단순 동치성 비교를 더해 순서까지 비교할 수 있으면 제네릭하기까지 한다.

### compareTo 메소드에 대해
- 우선 compareTo 메서드의 규약은 equals와 비슷하다 설명은 생략한다.
- 모든 객체에 대해 전역 동치관계를 부여하는 equals메서드와 달리, comepareTo는 타입이 다른 객체를 신경쓰지 않아도 된다. 
- 타입이 다른 객체가 주어지면 ClassCastException을 던져도 되며 대부분 그렇게하는 편이다.
- 비교를 활용하는 클래스의 예로는 정렬된 컬렉션인 treeset과 treemap, 검색과 정렬 알고리즘을 활용하는 유틸리티 클래스인 collections 과 array가 있다.

#### compareTo의 규약
- compareTo 규약을 자세히 살펴보면 첫번째 규약은 두 객체 참조의 순서를 바꿔 비교해도 예상한 결과가 나와야 한다는 얘기다. 
- 첫번째가 두번째보다 닥으면 두번째가 첫번째보다 커야함
- 두번째 규약은 첫번째가 두번째보다 크고 두번째가 세번째보다 크면, 첫번째는 세번째보다 커야 한다는 듯
- 마지막 규약은 크기가 같은 객체들 끼리는 어떤 객체와 비교하더라도 항상 같아야 한다는 것
- 마지막 규약의 경우 필수는 아니나 지키기를 권한다. 
- 동치성 테스트의 결과가 equals와 같아야 한다는 것이다. 
- 이를 잘 지키면, compareTo로 줄지은 순서와 equals의 결과가 일관되게 된다.

#### compareTo의 작성요령
- compareTo 메서드 작성요령은 equals와 비슷하다. 
- 몇가지 차이점만 주의하면 된다. 
  - Comparable은 타입을 인수로 받는 제네릭 인터페이스므로 compareTo 메서드의 인수 타입은 컴파일 타임에 정해진다. 
  - 입력 인수의 타입을 확인하거나 형변환 할 필요가 없다는 뜻이다.
- compareTo 메서드는 각 필드가 동치인지를 비교하는 것이 아니라 그 순서를 비교한다. 
- 객체 참조 필드를 구현하려면 compareTo메서드를 재귀적으로 호출한다. Comparable을 구현하지 않은 필드나 표준이 아닌 순서로 비교해야 한다면 비교자를 대신 사용한다.
- compareTo 메서드에서 관계 연산자<와> 를 사용하는 이전 방식은 거추장스럽고 오류를 유발하니 이제는 추천하지 않는다.

#### 결론
- 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여 그 인스턴스들을 쉽게 정렬하고 검색하고 비교 기능을 제공하는 컬렉션과 어우러지도록 해야한다.
- compareTo 메서드에서 필드의 값을 비교할 때 <와 >연산자는 쓰지 말아야 한다. 그 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare 메서드나 Comarator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.
