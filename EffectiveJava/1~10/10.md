## 3장 모든 객체의 공통 메서드

### 아이템 10 equals는 일반 규약을 지켜 재정의 하라

#### Equals를 재정의를 해야하는 이유
- 재정의를 하지 않는 한 두 클래스는 같은 클래스로 될 것 아래 상황 중 하나에 해당한다면 재정의 하지 않는 것이 최선
  - 인스턴스가 본질적으로 고유(값을 표현하는게 아니라 동작하는 개체를 표현할 때)
  - 인스턴스의 논리적 동치성을 검사할 일이 없다.
  - 상위 클래스에서 재정의한 equals가 하위클래스에도 딱 들어 맞는다. 
- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
- Equals를 재정의 해야 할 때는 객체 식별성, 두 객체가 물리적으로 같은가가 아니라 논리적 동치성을 확인해야 하는데 상위 클래스 equals가 논리적 동치성을 비교 하도록 재정의 되지 않았을 때 즉 값 클래스(Integer, String 등)가 여기 해당된다.

#### Equal 메서드를 재정의 할 때 반드시 일반 규약을 따라야 한다.
- 반사성 : null이 아닌 x에 대해 x.equals(x)는 true
- 대칭성 : null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)가 true면 y.equals(x)도 true이다.
- 추이성 : null 이 아닌 모든 참조값 x, y, z에 대해 x.equals(y)가 true이고 y.equals(z)도 true면 x.equals(z)도 true이다.
- 일관성 : null이 아닌 모든 참조값 x,y에 대해 x.equal(y)를 반복해서 호출하면 항상 true, false반환
- null이아님 : null이 아닌 모든 참조 값 x에 대해 x.equals(null)은 false이다.

#### 양질의 equals 메서드 구현 방법을 단계적으로 정리하면
1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인, 자기자신이면 true 단순한 성능 최적화용으로 비교 작업이 복잡한 상황일 때 값어치를 함
2. Instanceof 연산자로 입력이 올바른 타입인지 확인. 
   - 그렇지 않다면 false를 반환. 
   - 이떄의 올바른 타입은  equals가 정의된 클래스인 것이 보통이지만 가끔은 그 클래스가 구현한 특정 인터페이스가 될 수 있다.
3. 입력을 올바른 타입으로 형변환 한다. 
   - 앞서 2번에서 instanceof 검사를 했기 때문에 이 단계는 거의 성공한다.
4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 검사한다. 모든 필드가 일치하면 true를 하나라도 다르면 false반환

#### 구현 후
- 메서드 구현 후 대칭적인지, 추이성이 있는지 일관적인지 확인을 한다.
- Equals를 재정의 할 땐 hashcode도 반드시 재정의 하자, 또한 너무 복잡하게 해결하려고도 하지 말것
- 결론 꼭 필요한 경우가 아니면 equals를 재정의 하지 말자. 
  - 많은 경우에 object의 equals가 원하는 비교를 정확하게 수행해준다.
  -  재정의가 필요하다면 그 클래스의 핵심 필드를 모두 빠짐없이 위에서 기술한 5가지 규약을 확실히 지켜가며 비교해야함
