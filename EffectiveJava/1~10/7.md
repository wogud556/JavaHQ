### 아이템7 다 쓴 객체 참조를 해제하라

#### 자바는 가비지 컬렉터라 하여 다쓴 객체를 알아서 회수 해가는 시스템이 있다. 
- C나 c++은 free등으로 메모리 회수를 해야하지만 자바는 그럴 필요는 없다는 것이다. 라는 사실을 맹신해선 안된다.
  - 스택을 사용하는 프로그램을 오래 실행하였을 경우 가비지 컬렉션 활동과 메모리 사용량이 늘어나 결국 성능이 저하되는 현상이 드문 나타난다.
  - 심할 때는 디스크 페이징이나 outofMemoryError를 일으켜 프로그램이 예기치 않게 종료 되기도 한다.
#### 가비지 컬렉션 언어에서는 메모리 누수를 찾기가 매우 까다롭다. 
- 객체 참조 하나를 살려두면 가비지 컬랙터는 그 객체 뿐 아니라 그 객체가 참조하는 모든 객체를 회수해가지 못한다. 
  - 그래서 단 몇 개의 객체가 매우 많은 객체를 회수되지 못하게 할 수 있고 잠재적으로 악영향을 줄 수 있다.
  - 해법은 그냥 다쓴 참조에 null을 붙이면 됨.
- 다른 이점이 있다면 null처리한 객체를 사용하면 nullpointException을 던져주는데 이게 이미 null처리한 객체를 모르고 사용하였을 때 효과적이다.
  - 그렇다고 null처리를 굳이 무분별하게 할 필요는 없다. 
  - 객체 참조를 null처리하는 것은 예외적인 경우여야 한다. 
  - 다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위 밖으로 밀어내는 것이다.
- null처리는 메모리를 직접 관리하는 프로그램을 구현하였을 때 분명 메모리 누수에 유의해야 할 것이다.
- 여담으로 캐시 역시 메모리 누수를 일으키는 주범이다. 
  - 캐시의 역할 특성상 객체 참조를 캐시에 넣어놓고 이사실을 까맣게 잊은 채 그 객체를 다 쓴 뒤로도 한참을 그냥 뇌두는 일을 자주 접할 수 있다. 
  - 해법은 운좋게 키를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황이라면 weakHashMap을 사용해 캐시를 만들자.
- 메모리 누수의 세번째 주범은 리스너 혹은 콜백이라 부르는 것이다. 
  - 클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다면, 뭔가 조치해주지 않는 한 콜백은 계속 쌓여갈 것이다. 
  - 이때 콜백을 약한 참조로 저장하면 가비지 컬렉터가 즉시 수거해 간다.
