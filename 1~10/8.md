### 아이템 8 finalizer와 cleaner 사용을 피하라(예제 가져올것)

#### Finalizer의 필요성
- Finalizer 는 예측할 수 없고 상황에 따라 위험할 수 있어 일반적으로 불필요
  - 오동작, 낮은 성능, 이식성 문제의 원인이 된다고
  - Cleaner finalizer보다 덜 위험하지만, 예측할 수 없고, 느리고, 일반적으로 불필요하다.
  - C++ 개발자 독자들은 파괴자랑 햇갈리지 말 것(난 알바아님)

#### 해결
- 자바에서는 try-with-resource 와 try-finally를 사용해 해결한다.
- Finalizer와 cleaner로는 제떄 실행되어야 하는 작업은 절대 할 수 없다. 중대한 오류 야기 가능성
- 두 소멸자가 신속히 수행할 지는 전적으로 가비지 컬렉터의 알고리즘에 달림 가비지 컬랙터 구현마다 천차만별.
- Finalizer를 달아두면 그 인스턴스는 자원 회수를 제멋대로 지연한다. 
  - 일단 finalizer는 우선순위가 낮기 때문에 자원회수율이 적다.
  - 그래서 오류발생시 해결방안은 finalizer를 사용하지 않으면 됨
- 상태를 영구적으로 수정하는 작업에서는 절대로 finalizer나 cleaner에 의존해선 안된다.
- 예상치 못한 예외로 스레드가 멈추고, 스택 추적 내역을 뽑아야 하지만, finalizer는 그 경고조차 출력하지 않는다.

#### Finalizer, cleaner의 단점
- Finalizer, cleaner 는 심각한 성능 문제도 동반 대충 요약하면 상당히 느리다.
- Finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안문제를 일으킬 수 있음. 
  - finalizer공격 원리는 직렬화 과정에서 예외가 발생하면 생성되다 만 객체에서 악의적인 하위클래스 finalizer가 수행될 수 있게 한다. 
  - Final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무일도 하지 앟는 finalize 메서드를 만들고 final로 선언하라
- 해결법은 AutoClosable을 구현하고 close메소드를 호출하면 된다. 
  - Close 메소드에서는 객체는 더 이상 유효하지 않음을 필드에 기록하고 다른 메서드는 이 필드를 검사해서 객체가 닫힌 후에 불렀다면 illegalStateException을 던진다는 것.

#### 그런 Finalizer, cleaner을 써야한다면
- Finalizer와 cleaner의 사용처는 첫번째로 자원의 소유자가 close메서드를 호출하지 않는 것을 대비한 안전망(한마디로 1순위가 아닌 보험)역할 없느니만 못하진 않는다는 것 
- 두번째는 네이티브 피어와 연결된 객체에서 활용됨 네이티브 피어란 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말함 네이티브 피어는 자바 객체가 아니니 가비지 컬랙터는 그 존재를 알 수 없다.
- 결론은 cleaner finalizer는 안전망 역할이나 중요하지 않은 네이티브 자원회수용으로만 사용
