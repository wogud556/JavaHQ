### 아이템 11 equals를 재정의 하려거든 hashcode 도 재정의하라

#### 왜?
- Equals를 재정의한 클래스 모두에서 hashcode도 재정의 해야한다. 
  - 그렇지않으면 hashcode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 hashMap이나 hashset같은 컬렉션의 원소로 사용할 때 문제를 일으킨다.
- Hashcode 재정의를 잘못했을 떄 크게 문제되는 조항은 equals가 두 객체를 같다고 판단했다면, 두 객체의 hashcode는 똑같은 값을 반환해야 한다.

#### 좋은 해시함수라면
- 좋은 해시함수라면 서로 다른 인스터스에 대해 다른 해시코드를 반환한다. 
- 이것이 3번째 equals가 두 객체가 다르다고 판단했더라도 두 객체의 hashCode가 서로 다른 값을 반환할 필요가 없다. 
- 단 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 높아진다. 라는 규약이다.

#### 좋은 hashcode를 작성하는 요령
- 다음은 좋은 hashcode를 작성하는 요령
  - Int 변수 result 선언 후 c로 초기화, 이때 c는 해당 객체의 첫번째 핵심필드를 단계 2.a방식으로 계산한 해시코드이다.
  - 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행한다.
    - 해당 필드의 해시코드 c를 계산한다
    - 기본 타입 필드라면 type.hashCode(f)를 수행한다. 여기서 type은 해당 기본 타입의 박싱 클래스이다.
    - 참조 타입 필드면서 이 클래스의 equals 메서드가 이 필드의 equals를 재귀적으로 호출해 비교한다면, 이 필드의 hashcode를 재귀적으로 호출한다.
    - 계산이 복잡해질거 같으면, 이 필드의 표준형을 만들어 그 표준형의 hashcode를 호출한다. 
    - 필드값이 null이면 0을 사용한다.
  - 필드가 배열이라면 핵심 원소 각각을 별도 필드처럼 다룬다. 
    - 이상의 규칙을 재귀적으로 적용해 각 핵심 원소의 해시코드를 계산한 다음 단계 2.b 방식으로 갱신한다. 
    - 배열에 핵심 원소가 하나도 없다면 단순히 상수(0 추천)를 사용한다. 모든 원소가 핵심원소라면, Array.hashCode를 사용한다.
  - 단계 2.a에서 계산한 코드 c로 result를 갱신한다. 코드로는 다음과 같다
    - Result = 31 * result + c;
    - Result를 반환한다.
  - Hashcode를 구현했다면 메서드가 동치인 인스턴스에 대해 똑 같은 코드를 반환할지 자문해보고 단위테스트가 완료되면 동치인 인스턴스가 다른 코드를 반환한다면 원인을 찾아 해결하자.
  - 또한 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해선 안된다.
  - 속도는 빠르게씩만, 해시 품질이 나빠져 해시테이블의 성능을 심각하게 떨어뜨린다.
- Hash code가 반환하는 값의 생성규칙을 api 사용자에게 자세히 공표하지 말자. 
  - 그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후에 계산 방식을 바꿀 수 있다.

#### 결론
- equals를 재정의할 때 hashcode도 반드시 재정의 해야한다. 
- 그렇지 않으면 프로그램이 제대로 동작하지 않을 것이다. 
- 재정의한 hashcode는 object의 api문서에 기술한 일반 규약을 따라야 하며, 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 한다. 
- 이렇게 구현하기가 어렵지는 않지만 조금 따분하긴 하다.
