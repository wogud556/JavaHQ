### 13 Cloneable

#### Cloneable 메서드

- Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스지만, 아쉽게도 의도한 목적을 제대로 이루지 못했다.
- 우선 clone 메서드가 선언된 곳이 cloneable이 아닌 object이고, 그마저도 protected라는데 있다.
- 실무에서 cloneable을 구현한 클래스는 clone 메서드를 public 으로 제공하며, 사용자는 당연히 복제가 제대로 이루어지리라 기대한다. 
- 이 기대를 만족하려면 그 클래스와 모든 상위 클래스는 복잡하고, 강제할수 없고, 허술하게 기술된 프로토콜을 지켜야만 한다.
-	Clone 메서드의 일반 규약은 허술하다. 짧게 설명하면
    - 이 객체의 복사본을 생성해 반환한다 복사의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있다. 
    - 관례상 이 메서드가 반환하는 객체는 super.clone을 호출해 얻어야 한다.
-	강제성이 없다는 점만 빼면 생성자 연쇄와 살짝 비슷한 메커니즘이다. 즉 clone메서드가 super.clone이 아닌 생성자를 호출해 얻은 인스턴스를 반환해도 컴파일러는 불평하지 않을 것이다.
-	clone메서드는 사실상 생성자와 같은 효과를 낸다. 즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.
-	한편 elements 필드가 final이었다면 앞서 방식은 작동하지 않는다. 
- Final 필드에는 새로운 값을 할당할 수 없기 때문이다. 
  - 이는 근본적인 문제로, 직렬화와 마찬가지로 cloneable 아키텍쳐는 가변 객체를 참조하는 필드는 final로 선언하라는 일반 용법과 충돌한다.

### 결론
- cloneable이 몰고 온 모든 문제를 되짚어 봤을 떄 새로운 인터페이스를 만들 때는 절대로 cloneable을 확장해선 안되고 새로운 클래스도 이를 구현해선 안된다. 기본 원칙은 생성자와 팩터리를 이용하는게 최고라는 것이다. 단 배열만은 clone메서드 방식이 가장 깔끔한 이 규칙의 합당한 예외라 할 수 있음
